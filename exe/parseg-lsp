#!/usr/bin/env ruby

require "language_server-protocol"
require "parseg"
require "uri"
require "pp"
require "rbs"
require "strscan"
require "optparse"

def empty_binding
  binding
end

error_tolerant_enabled = true
skip_tokens_enabled = true

OptionParser.new do |opts|
  opts.on("--no-error-tolerant") do
    error_tolerant_enabled = false
  end
  opts.on("--no-skip-tokens") do
    skip_tokens_enabled = false
  end
end.parse!(ARGV)

# @type const LSP: untyped

LSP = LanguageServer::Protocol

file = ARGV[0]
rule = ARGV[1].to_sym

STDERR.puts "Loading grammar from #{file}..."

# @type var tokenizer: ^(String) -> Parseg::_Tokenizer
# @type var grammar: Parseg::Grammar
tokenizer, grammar = eval(File.read(file), empty_binding, file)

writer = LSP::Transport::Stdio::Writer.new
reader = LSP::Transport::Stdio::Reader.new

trees = {} #: Hash[String, [Parseg::Result, String, Range[Integer]?]]

STDERR.puts "Starting loop..."

reader.read do |request|
  STDERR.puts "‚è© method = #{request[:method]}, id=#{request[:id]}, params=#{request[:params].inspect}"

  method = request[:method].to_sym

  case method
  when :initialize
    response = {
      capabilities: {
        textDocumentSync: {
          openClose: true,
          save: true,
          change: LSP::Constant::TextDocumentSyncKind::INCREMENTAL
        },
        documentSymbolProvider: {
          label: "Parseg demo"
        }
      }
    }
  when :"textDocument/didChange"
    uri = request[:params][:textDocument][:uri]
    changes = request[:params][:contentChanges]
    _, content, range = trees[uri]

    changes.each do |change|
      buffer = RBS::Buffer.new(name: uri, content: content)

      start_line = change[:range][:start][:line] + 1
      start_column = change[:range][:start][:character]

      end_line = change[:range][:end][:line] + 1
      end_column = change[:range][:end][:character]

      changed_range = buffer.loc_to_pos([start_line, start_column]) ...  buffer.loc_to_pos([end_line, end_column])
      content[changed_range] = change[:text]

      if range
        if changed_range.begin < range.begin
          range = changed_range.begin ... range.begin
        end
        if range.end < changed_range.end
          range = range.end ... changed_range.end
        end
      else
        range = changed_range
      end
    end

    parser = Parseg::Parser.new(grammar: grammar, tokenizer: tokenizer[content])
    parser.error_tolerant_enabled = error_tolerant_enabled
    parser.skip_unknown_tokens_enabled = skip_tokens_enabled
    result = parser.parse(grammar.non_terminals[rule])
    trees[uri] = [result, content, nil]

  when :"textDocument/didOpen"
    uri = request[:params][:textDocument][:uri]
    text = request[:params][:textDocument][:text]

    start = grammar.non_terminals[rule]
    tok = tokenizer[text]

    parser = Parseg::Parser.new(grammar: grammar, tokenizer: tokenizer[text])
    parser.error_tolerant_enabled = error_tolerant_enabled
    parser.skip_unknown_tokens_enabled = skip_tokens_enabled
    result = parser.parse(start)

    trees[uri] = [
      result,
      text,
      nil
    ]

  when :"textDocument/didClose"
    uri = request[:params][:textDocument][:uri]
    trees.delete(uri)

  when :"textDocument/documentSymbol"
    uri = request[:params][:textDocument][:uri]
    result, content, _ = trees[uri]
    buffer = RBS::Buffer.new(name: uri, content: content)

    formatter = Parseg::LspTreeFormatter.new(result.token_locator, buffer)
    response = formatter.format_tree(result.tree, last_position: { line: 0, character: 0 })

    diagnostics = [] #: Array[LanguageServer::Protocol::Interface::Diagnostic]

    result.skip_tokens.each do |token_id|
      _, type, offset, value = result.token_locator.token(token_id)

      range = result.token_locator.token_range(token_id)
      start_line, start_column = buffer.pos_to_loc(range.begin)
      end_line, end_column = buffer.pos_to_loc(range.end)

      diagnostics << LanguageServer::Protocol::Interface::Diagnostic.new(
        range: {
          start: { line: start_line - 1, character: start_column },
          end: { line: end_line - 1, character: end_column }
        },
        severity: LanguageServer::Protocol::Constant::DiagnosticSeverity::INFORMATION,
        message: "Token skipped: #{type}, #{value}"
      )
    end

    result.each_error_tree() do |error|
      if error.token
        _, type, offset, value = result.token_locator.token(error.token)

        range = result.token_locator.token_range(error.token)
        start_line, start_column = buffer.pos_to_loc(range.begin)
        end_line, end_column = buffer.pos_to_loc(range.end)

        diagnostic = LanguageServer::Protocol::Interface::Diagnostic.new(
          range: {
            start: { line: start_line - 1, character: start_column },
            end: { line: end_line - 1, character: end_column }
          },
          severity: LanguageServer::Protocol::Constant::DiagnosticSeverity::INFORMATION,
          message: "Unexpected token: #{type}, #{value}, expected tokens: #{error.expression.first_tokens}"
        )

        diagnostics << diagnostic
      end
    end

    STDERR.puts "Sending publishDiagnostics notification with #{diagnostics.size} diagnostics"

    writer.write(
      method: "textDocument/publishDiagnostics",
      params: {
        uri: uri,
        diagnostics: diagnostics
      }
    )
  end

  if request[:id]
    STDERR.puts "Sending response to #{request[:id]}..."
    writer.write(id: request[:id], result: response)
  end
end
