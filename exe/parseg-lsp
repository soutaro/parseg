#!/usr/bin/env ruby

require "language_server-protocol"
require "parseg"
require "uri"
require "pp"
require "rbs"
require "strscan"
require "optparse"

def empty_binding
  binding
end

error_tolerant_enabled = true
skip_tokens_enabled = true

OptionParser.new do |opts|
  opts.on("--no-error-tolerant") do
    error_tolerant_enabled = false
  end
  opts.on("--no-skip-tokens") do
    skip_tokens_enabled = false
  end
end.parse!(ARGV)

# @type const LSP: untyped

LSP = LanguageServer::Protocol

file = ARGV[0]
rule = ARGV[1].to_sym

STDERR.puts "Loading grammar from #{file}..."

# @type var tokenizer: Parseg::_Tokenizer
# @type var grammar: Parseg::Grammar
tokenizer, grammar = eval(File.read(file), __skip__ = empty_binding, file)

writer = LSP::Transport::Stdio::Writer.new
reader = LSP::Transport::Stdio::Reader.new

trees = {} #: Hash[String, [Parseg::Result, Parseg::Result?]]

STDERR.puts "Starting loop..."

reader.read do |request|
  STDERR.puts "â© method = #{request[:method]}, id=#{request[:id]}, params=#{request[:params].inspect}"

  method = request[:method].to_sym

  case method
  when :initialize
    response = {
      capabilities: {
        textDocumentSync: {
          openClose: true,
          save: true,
          change: LSP::Constant::TextDocumentSyncKind::INCREMENTAL
        },
        documentSymbolProvider: {
          label: "Parseg demo"
        }
      }
    }
  when :"textDocument/didChange"
    # @type var uri: String
    # @type var changes: Array[Parseg::TokenFactory::change]
    uri = request[:params][:textDocument][:uri]
    changes = request[:params][:contentChanges].map do |change|
      start_line = change[:range][:start][:line] + 1
      start_column = change[:range][:start][:character]

      end_line = change[:range][:end][:line] + 1
      end_column = change[:range][:end][:character]

      [
        change[:text],
        [start_line, start_column],
        [end_line, end_column]
      ]
    end
    last_result, last_successful_result = trees[uri]

    factory_with_changes = last_result.factory.update(changes)

    STDERR.puts "Running parser with #{factory_with_changes.incoming_changes.size} pending changes..."
    factory_with_changes.source.each_line() do |line|
      STDERR.puts "> #{line.chomp}"
    end

    result = Parseg::Parser.new(grammar: grammar, factory: factory_with_changes.reset).yield_self do |parser|
      parser.error_tolerant_enabled = error_tolerant_enabled
      parser.skip_unknown_tokens_enabled = skip_tokens_enabled
      parser.parse(grammar.non_terminals[rule])
    end

    if result.has_error?
      deleted_tokens = factory_with_changes.deleted_tokens
      STDERR.puts "#{deleted_tokens.size} tokens are deleted"

      if last_successful_result
        if factory_with_changes.inserted_tokens.empty? && !deleted_tokens.empty?
          tree_changed_factory = last_successful_result.factory
          deleted_tokens.each_key do |token_id|
            if range = last_successful_result.tree_range_for_deleted_token(token_id)
              tree_changed_factory = tree_changed_factory.with_additional_change(range)
            end
          end
          factory_with_changes = tree_changed_factory.update(factory_with_changes.incoming_changes)
        end
      end

      result = Parseg::Parser.new(grammar: grammar, factory: factory_with_changes).yield_self do |parser|
        parser.error_tolerant_enabled = error_tolerant_enabled
        parser.skip_unknown_tokens_enabled = skip_tokens_enabled
        parser.parse(grammar.non_terminals[rule])
      end
    else
      last_successful_result = result
    end

    trees[uri] = [result, last_successful_result]

  when :"textDocument/didOpen"
    uri = request[:params][:textDocument][:uri]
    text = request[:params][:textDocument][:text]

    start = grammar.non_terminals[rule]

    factory = Parseg::TokenFactory.new(tokenizer: tokenizer, status: text)

    parser = Parseg::Parser.new(grammar: grammar, factory: factory)
    parser.error_tolerant_enabled = error_tolerant_enabled
    parser.skip_unknown_tokens_enabled = skip_tokens_enabled
    result = parser.parse(start)

    unless result.has_error?
      successful_result = result
    end
    trees[uri] = [result, successful_result]

  when :"textDocument/didClose"
    uri = request[:params][:textDocument][:uri]
    trees.delete(uri)

  when :"textDocument/documentSymbol"
    uri = request[:params][:textDocument][:uri]
    result, _ = trees[uri]
    content = result.factory.source
    buffer = RBS::Buffer.new(name: uri, content: content)

    formatter = Parseg::LspTreeFormatter.new(result.factory, buffer)
    response = formatter.format_tree(result.tree, last_position: { line: 0, character: 0 })

    diagnostics = [] #: Array[LanguageServer::Protocol::Interface::Diagnostic]

    result.skip_tokens.each do |token_id|
      type, offset, value = result.factory.token(token_id)

      range = result.factory.token_range(token_id)
      start_line, start_column = buffer.pos_to_loc(range.begin)
      end_line, end_column = buffer.pos_to_loc(range.end)

      diagnostics << LanguageServer::Protocol::Interface::Diagnostic.new(
        range: {
          start: { line: start_line - 1, character: start_column },
          end: { line: end_line - 1, character: end_column }
        },
        severity: LanguageServer::Protocol::Constant::DiagnosticSeverity::WARNING,
        message: "Token skipped: type=#{type} (`#{value}`)"
      )
    end

    # result.each_error_tree() do |tree|  end
    #   range = tree.range(result.token_locator) or next

    #   start_line, start_column = buffer.pos_to_loc(range.begin)
    #   end_line, end_column = buffer.pos_to_loc(range.end)

    #   toks = missings.each.with_object(Set[]) do |missing, set|
    #     set.merge(missing.expression.first_tokens)
    #   end

    #   diagnostic = LanguageServer::Protocol::Interface::Diagnostic.new(
    #     range: {
    #       start: { line: start_line - 1, character: start_column },
    #       end: { line: end_line - 1, character: end_column }
    #     },
    #     severity: LanguageServer::Protocol::Constant::DiagnosticSeverity::WARNING,
    #     message: "Unexpected token: #{toks} are expected"
    #   )

    #   diagnostics << diagnostic
    # end

    result.each_error_tree() do |error|
      if error.token
        type, offset, value = result.factory.token(error.token)

        range = result.factory.token_range(error.token)
        start_line, start_column = buffer.pos_to_loc(range.begin)
        end_line, end_column = buffer.pos_to_loc(range.end)

        expr =
          case error.expression
          when Parseg::Grammar::Expression::TokenSymbol
            "T(:#{error.expression.token})"
          when Parseg::Grammar::Expression::NonTerminalSymbol
            "NT(:#{error.expression.non_terminal.name})"
          else
            "(#{error.expression.class.name})"
          end

        diagnostic = LanguageServer::Protocol::Interface::Diagnostic.new(
          range: {
            start: { line: start_line - 1, character: start_column },
            end: { line: end_line - 1, character: end_column }
          },
          severity: LanguageServer::Protocol::Constant::DiagnosticSeverity::ERROR,
          message: "Unexpected token: type=#{type}, value=#{value}, expected tokens by #{expr}: #{error.expression.first_tokens}"
        )

        diagnostics << diagnostic
      end
    end

    if range = result.factory.surrounding_changed_range
      start_line, start_column = buffer.pos_to_loc(range.begin)
      end_line, end_column = buffer.pos_to_loc(range.end)

      diagnostic = LanguageServer::Protocol::Interface::Diagnostic.new(
        range: {
          start: { line: start_line - 1, character: start_column },
          end: { line: end_line - 1, character: end_column }
        },
        severity: LanguageServer::Protocol::Constant::DiagnosticSeverity::INFORMATION,
        message: "Changed after last parsing success"
      )

      diagnostics << diagnostic
    end

    STDERR.puts "Sending publishDiagnostics notification with #{diagnostics.size} diagnostics"

    writer.write(
      method: "textDocument/publishDiagnostics",
      params: {
        uri: uri,
        diagnostics: diagnostics
      }
    )
  end

  if request[:id]
    STDERR.puts "Sending response to #{request[:id]}..."
    writer.write(id: request[:id], result: response)
  end
end
