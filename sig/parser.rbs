module Parseg
  #
  # # Tokens
  #
  # Parser has one token that is returned from `#current_token`.
  #
  #
  class Parser
    attr_reader grammar: Grammar

    attr_reader tokenizer: _Tokenizer

    attr_reader token_locator: TokenLocator

    # `true` to enable *skip unknown tokens* feature
    attr_accessor skip_unknown_tokens_enabled: bool

    # `true` to enable *error tolerant* mode
    attr_accessor error_tolerant_enabled: bool

    @token_id: Integer

    @current_token: token?

    def initialize: (grammar: Grammar, tokenizer: _Tokenizer) -> void

    def parse: (Grammar::NonTerminal) -> Result

    private

    @exit_symbol: Symbol?

    # Update `#current_token` by reading a token from `#tokenizer`
    #
    # Returns the old `#current_token`.
    #
    def advance_token: () -> token?

    # Update `#current_token` by reading a token from `#rokenizer`
    #
    # Returns the old `#current_token`.
    # Raises an exception if `#current_token` is `nil`.
    #
    def advance_token!: () -> token

    # Returns the token at the head of the input
    #
    %a{pure} def current_token: () -> token?

    # Returns the token at the head of the input or raise an exception
    #
    def current_token!: () -> token

    # Returns `#id` of `#current_token`
    #
    %a{pure} def token_id: () -> Integer?

    # Returns `#id` of `#current_token`
    #
    # Raises an exception if `#current_token` is `nil`.
    #
    def token_id!: () -> Integer

    # Returns the `#type` of the `#current_token`
    %a{pure} def token_type: () -> Symbol?

    def parse_rule: (Grammar::Expression::t, Set[Symbol?] next_tokens, Array[Integer] skip_tokens) -> Tree::t

    def skip_unknown_tokens: (Set[Symbol?] next_tokens, Grammar::Expression::t? next_expr, Array[Integer] skip_tokens) -> token?

    def with_next_tokens: [T] (Set[Symbol?], Grammar::Expression::t?) { (Set[Symbol?]) -> T } -> T

    def throw_error_tree: (Tree::MissingTree) -> bot
  end
end
