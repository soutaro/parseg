module Parseg
  class Grammar
    module Expression
      type t = TokenSymbol
             | NonTerminalSymbol
             | Alternation
             | Repeat
             | Optional
             | Empty

      interface _Expression
        %a{pure} def next_expr: () -> t?

        def my_first_tokens: () -> Set[Symbol | nil]

        # Set of tokens that can be used to construct a tree that corresponds to the expression
        #
        def consumable_tokens: () -> Set[Symbol]
      end

      module FirstTokensUtil : _Expression
        def first_tokens: () -> Set[Symbol | nil]
      end

      class TokenSymbol
        attr_reader token: Symbol

        attr_reader next_expr: t?

        include FirstTokensUtil

        def initialize: (Symbol, ?next_expr: t?) -> void

        def my_first_tokens: () -> Set[Symbol | nil]

        def +: (t) -> TokenSymbol

        def consumable_tokens: () -> Set[Symbol]
      end

      class NonTerminalSymbol
        include FirstTokensUtil

        attr_reader non_terminal: NonTerminal

        attr_reader next_expr: t?

        def initialize: (NonTerminal, ?next_expr: t?) -> void

        def my_first_tokens: () -> Set[Symbol | nil]

        def +: (t) -> NonTerminalSymbol

        def consumable_tokens: () -> Set[Symbol]
      end

      class Empty
        include FirstTokensUtil

        attr_reader next_expr: t?

        def +: (t) -> t

        @@instance: Empty
        def self.instance: () -> Empty

        def my_first_tokens: () -> Set[Symbol | nil]

        def consumable_tokens: () -> Set[Symbol]
      end

      class Alternation
        include FirstTokensUtil

        attr_reader expressions: Array[t]

        attr_reader next_expr: t?

        def initialize: (*t, ?next_expr: t?) -> void

        def my_first_tokens: () -> Set[Symbol | nil]

        def +: (t) -> Alternation

        def consumable_tokens: () -> Set[Symbol]
      end

      class Repeat
        include FirstTokensUtil

        attr_reader content: t
        attr_reader separator: t

        attr_reader next_expr: t?

        def initialize: (content: t, separator: t, ?next_expr: t?) -> void

        def my_first_tokens: () -> Set[Symbol | nil]

        def +: (t) -> Repeat

        def consumable_tokens: () -> Set[Symbol]
      end

      class Optional
        include FirstTokensUtil

        attr_reader expression: t

        attr_reader next_expr: t?

        def initialize: (t, ?next_expr: t?) -> void

        def my_first_tokens: () -> Set[Symbol | nil]

        def +: (t) -> Optional

        def consumable_tokens: () -> Set[Symbol]
      end
    end

    class NonTerminal
      attr_accessor rule: Expression::NonTerminalSymbol | Expression::Empty

      attr_reader name: Symbol

      def initialize: (Symbol) -> void
    end

    interface _WithGrammar
      def grammar: () -> Grammar
    end

    module DSL : _WithGrammar
      def T: (Symbol) -> Expression::TokenSymbol

      def NT: (Symbol) -> Expression::NonTerminalSymbol

      def Opt: (Expression::t) -> Expression::Optional

      def Repeat: (Expression::t, ?Expression::t) -> Expression::Repeat

      def Alt: (*Expression::t) -> Expression::Alternation

      def Empty: () -> Expression::Empty
    end

    attr_reader non_terminals: Hash[Symbol, NonTerminal]

    def initialize: (*Symbol) ?{ (Grammar) [self: DSL] -> void } -> void

    def []: (Symbol) -> NonTerminal
  end
end
